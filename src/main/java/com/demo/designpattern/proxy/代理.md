### JDK代理：
* 默认的
* 有顶层接口
* 接口动态代理需要2步
    * 第一步：定义额外的操作
*  通过实现 InvocationHandler 接口，来定义在执行代理对象方法前后自己的动作。
    * 第二步：获取代理对象
*  通过 Proxy.newProxyInstance 获取代理对象，这一步的作用是根据指定的:
    1. ClassLoader
    2. 要代理的接口，
    3. 以及传递进来的处理者。来生成真正的代理对象
* jdk代理针对的是对象，所以需要传new真正的对象    
--------------------- 
### CGLIB动态代理：
* 第一步：定义额外的操作
    * 通过实现 MethodInterceptor 接口，来定义在执行代理对象方法前后自己的动作。
* 第二步：获取代理对象
    * 通过 Enhancer.create 获取代理对象，因为这个只需要
* CGLIB代理针对的是类，所以不需要传递对象

### JDK代理和CGLIB代理的区别
一、简单来说：
* JDK动态代理只能对实现了接口的类生成代理，而不能针对类。
* CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法（继承）。

二、Spring在选择用JDK还是CGLIB的依据：
1. 当Bean实现接口时，Spring就会用JDK的动态代理。
2. 当Bean没有实现接口时，Spring使用CGLIB实现。
3. 可以强制使用CGLIB（在Spring配置中加入）

三、CGLIB比JDK快？
1. 使用CGLIB实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，比使用Java反射效率要高。唯一需要注意的是，CGLIB不能对声明为final的方法进行代理，因为CGLIB原理是动态生成被代理类的子类。
2. 在对JDK动态代理与CGLIB动态代理的代码实验中看，1W次执行下，JDK7及8的动态代理性能比CGLIB要好20%左右。
